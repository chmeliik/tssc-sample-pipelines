apiVersion: tekton.dev/v1
kind: Task
metadata:
  annotations:
    tekton.dev/tags: "sbom, attestation, cosign"
  name: download-sbom-from-url-in-attestation
spec:
  description: |-
    Get the SBOM for an image by downloading the OCI blob referenced in the image attestation.
  params:
  - name: IMAGES
    description: Download SBOMs for these images
    type: array

  - name: SBOMS_DIR
    default: "."
    description: >-
      Path to directory (relative to the 'sboms' workspace) where SBOMs should be downloaded.
    type: string

  - name: HTTP_RETRIES
    default: "3"
    description: "Maximum number of retries for transient HTTP(S) errors"
    type: string

  - name: PUBLIC_KEY
    type: string
    description: >-
      Public key used to verify signatures. Must be a valid k8s cosign
      reference, e.g. k8s://my-space/my-secret where my-secret contains
      the expected cosign.pub attribute.
    default: ""

  - name: REKOR_HOST
    type: string
    description: Rekor host for transparency log lookups
    default: ""

  - name: IGNORE_REKOR
    type: string
    description: >-
      Skip Rekor transparency log checks during validation.
    default: "false"

  - name: TUF_MIRROR
    type: string
    description: TUF mirror URL. Provide a value when NOT using public sigstore deployment.
    default: ""
  workspaces:
  - name: sboms
    description: SBOMs will be downloaded to (a subdirectory of) this workspace.
  stepTemplate:
    env:
    - name: SBOMS_DIR
      value: $(workspaces.sboms.path)/$(params.SBOMS_DIR)
    - name: HTTP_RETRIES
      value: $(params.HTTP_RETRIES)
    - name: PUBLIC_KEY
      value: $(params.PUBLIC_KEY)
    - name: REKOR_HOST
      value: $(params.REKOR_HOST)
    - name: IGNORE_REKOR
      value: $(params.IGNORE_REKOR)
    - name: TUF_MIRROR
      value: $(params.TUF_MIRROR)
    - name: WORKDIR
      value: /tekton/home
  steps:
  - name: download-attestations
    image: quay.io/redhat-appstudio/appstudio-utils:5bd7d6cb0b17f9f2eab043a8ad16ba3d90551bc2@sha256:8c7fcf86af40c71aeb58e4279625c8308af5144e2f6b8e28b0ec7e795260e5f7
    script: |
      #!/usr/bin/env bash
      set -o errexit -o nounset -o pipefail

      if [[ -z "$PUBLIC_KEY" ]]; then
        echo "No public key set, cannot verify attestation." >&2
        exit 1
      fi

      cosign_args=(--key "$PUBLIC_KEY")

      if [[ -n "$REKOR_HOST" ]]; then
        cosign_args+=(--rekor-url "$REKOR_HOST")
      elif [[ "$IGNORE_REKOR" = "true" ]]; then
        cosign_args+=(--insecure-ignore-tlog)
      else
        cosign_args+=()
      fi

      if [[ -n "${TUF_MIRROR:-}" ]]; then
        echo 'Initializing TUF root...'
        cosign initialize --mirror "${TUF_MIRROR}" --root "${TUF_MIRROR}/root.json"
      fi

      for image in "$@"; do
        echo "Getting attestation for $image"
        mkdir -p "$WORKDIR/$image"
        cosign verify-attestation \
          --type slsaprovenance \
          "${cosign_args[@]}" \
          "$image" > "$WORKDIR/$image/attestation.json"
      done
    args:
    - $(params.IMAGES[*])

  - name: do-magic
    image: quay.io/redhat-appstudio/appstudio-utils:5bd7d6cb0b17f9f2eab043a8ad16ba3d90551bc2@sha256:8c7fcf86af40c71aeb58e4279625c8308af5144e2f6b8e28b0ec7e795260e5f7
    script: |
      #!/usr/bin/env bash
      set -o errexit -o nounset -o pipefail

      get_from_www_auth_header() {
          local www_authenticate=$1
          local key=$2
          # shellcheck disable=SC2001
          # E.g.
          #   www_authenticate='Bearer realm="https://ghcr.io/token",service="ghcr.io"'
          #   key=service
          #   -> ghcr.io
          sed "s/.*$key=\"\([^\"]*\)\".*/\1/" <<< "$www_authenticate"
      }

      get_container_auth() {
          # https://man.archlinux.org/man/containers-auth.json.5

          local image=$1

          local runtime_dir="${XDG_RUNTIME_DIR:-}"
          local config_home="${XDG_CONFIG_HOME:-$HOME/.config}"
          if [[ -n "$runtime_dir" ]]; then
              default_authfile="${runtime_dir}/containers/auth.json"
          else
              default_authfile="$config_home/containers/auth.json"
          fi

          local primary_auth_file="${REGISTRY_AUTH_FILE:-$default_authfile}"

          local maybe_auth_files=(
              "$primary_auth_file"
              "$config_home/containers/auth.json"
              "$HOME/.docker/config.json"
              "$HOME/.dockercfg"
          )
          local auth_files=()
          for file in "${maybe_auth_files[@]}"; do
              if [[ -r "$file" ]]; then
                  auth_files+=("$file")
              fi
          done

          # registry.com/namespace/repo@sha256:digest -> registry.com/namespace/repo
          local auth_key=${image%@*}

          while true; do
              for auth_file in "${auth_files[@]}"; do
                  if jq -r -e --arg key "$auth_key" '.auths[$key].auth // empty' "$auth_file"; then
                      echo "Found auth for $auth_key in $auth_file" >&2
                      return 0
                  fi
              done

              # Try less specific key, e.g. registry.com/namespace/repo -> registry.com/namespace
              local new_key=${auth_key%/*}
              if [[ "$new_key" = "$auth_key" ]]; then
                  # Already tried all possible keys, no auth found
                  echo "No auth found for $auth_key" >&2
                  return 1
              fi

              auth_key=$new_key
          done

      }

      download_blob() {
        local blob_ref=$1
        local dest=${2:-/dev/stdout}

        # convert:
        #     registry.com/namespace/repo@sha256:digest
        # ->  https://registry.com/v2/namespace/repo/blobs/sha256:digest
        blob_url=$(sed -E 's;([^/]*)/(.*)@(.*);https://\1/v2/\2/blobs/\3;' <<< "$blob_ref")

        local tmp_dest=$(mktemp --tmpdir)

        local common_curl_opts=(--silent --show-error --retry "${HTTP_RETRIES:-3}")

        echo "GET $blob_url" >&2
        local outputs
        mapfile -t outputs < <(curl \
            "${common_curl_opts[@]}" \
            -L \
            --write-out '%header{www-authenticate}\n%{response_code}' \
            --output "$tmp_dest" \
            "$blob_url"
        )
        local www_authenticate=${outputs[0]}
        local response_code=${outputs[1]}

        if [[ "$response_code" -eq 200 ]]; then
            # Blob download didn't require auth, we're done
            :
        elif [[ "$response_code" -eq 401 ]]; then
            echo "Got 401, trying to authenticate" >&2

            local realm service scope token_url
            realm=$(get_from_www_auth_header "$www_authenticate" realm)
            service=$(get_from_www_auth_header "$www_authenticate" service)
            scope=$(get_from_www_auth_header "$www_authenticate" scope)
            token_url=$(jq -n -r --arg realm "$realm" --arg service "$service" --arg scope "$scope" \
                '"\($realm)?service=\($service | @uri)&scope=\($scope | @uri)"'
            )

            local basic_auth token_auth
            if basic_auth=$(get_container_auth "$blob_ref"); then
                token_auth=(-H "authorization: Basic $basic_auth")
            else
                echo "Trying to get token anonymously" >&2
                token_auth=()
            fi

            echo "GET $token_url" >&2
            token=$(curl \
                "${common_curl_opts[@]}" \
                "${token_auth[@]}" \
                --fail-with-body \
                "$token_url" | jq -r .token
            )

            echo "GET $blob_url" >&2
            curl \
                "${common_curl_opts[@]}" \
                -L \
                --output "$tmp_dest" \
                --fail-with-body \
                -H "authorization: Bearer $token" \
                "$blob_url"
        else
            echo "Error: unexpected response code: $response_code!" >&2
            return 1
        fi

        cp "$tmp_dest" "$dest"
      }

      for image in "$@"; do
        attestation_file="$WORKDIR/$image/attestation.json"
        sbom_blob_url=$(jq -r \
          '.payload | @base64d | fromjson | .. | select(.name? == "SBOM_BLOB_URL").value' \
          "$attestation_file"
        )
        mkdir -p "$SBOMS_DIR/$image"
        download_blob "$sbom_blob_url" "$SBOMS_DIR/$image/sbom.json"
      done
    args:
    - $(params.IMAGES[*])
